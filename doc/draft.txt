
Flags
    Z   zero flag
    C   carry flag
    S   sign flag



types d'opérandes
    vide
        ----
    constante
        "1"
    registre
        next-environment
            ne
        previous-environment
            pe
        program-counter
            pc
        stack-pointer
            sp
        interrupt-handler
            ih
        data-index
            di
        data-length
            dl
        accumulator
            ac
        flag-register
            fl
    mémoire
        à telle adresse en première page du thread (1 octet)
            [0x00]
        à telle adresse en mémoire globale (2 octets)
            [0x0000]
    valeur
        1 octet
            0x00
        2 octets
            0x0000
    label
        contenu du label
            [foo]
        adresse du label
            foo



Load Group
Exchange, Block Transfer, and Search Group
Arithmetic Group
General-Purpose Arithmetic and CPU Control Groups
Rotate and Shift Group
Bit Set, Reset, and Test Group
Jump Group
Call and Return Group
Input and Output Group


















1   cmp [0x00] 0x0000
    compare une adresse en 1ère page avec une constante

2   cmp [0x00] [0x0000]
    compare une adresse en 1ère page avec une adresse globale
    
2   cmp [0x00] [label]
    compare une adresse en 1ère page avec un label
    
3   cmpa ---- 0x0000
    compare une adresse l'accumulateur avec une constante

4   cmpa ---- [0x0000]
    compare une adresse l'accumulateur avec une adresse globale

4   cmpa ---- [label]
    compare une adresse l'accumulateur avec une adresse globale

5   jmp "0" 0x0000
    transfère l'exécution à une adresse globale

5   jmp "1" [0x0000]
    transfère l'exécution à une adresse contenue à une adresse globale

5   jmp "1" [label]
    transfère l'exécution à une adresse contenue à une adresse globale






================================================================================ 18/11/2019
== Instructions / modes d'adressage



Code  Mode d'adressage                       Taille  Description
----  ----------------                       ------  -----------
IM    Immediate Addressing                   1       constant byte as operand
IMX   Immediate Extended Addressing          2       constant word as operand
DR    Direct Relative Addressing             1       signed byte + current PC is the address of the operand
DRX   Direct Relative Extended Addressing    2       signed word + current PC is the address of the operand
DE    Direct Environment Addressing          1       envregister that contains the operand
DZ    Direct Page Zero Addressing            1       address in page zero that contains the operand
DG    Direct Global Addressing               2       real address that contains the operand
DI    Direct Indexed Addressing              2       address relative to dataIndex that contains the operand
IR    Indirect Relative Addressing           1       signed byte + current PC is the address of the address of the operand
IRX   Indirect Relative Extended Addressing  2       signed word + current PC is the address of the address of the operand
IE	Indirect Environment Addressing          1       envregister that contains the address of the operand
IZ	Indirect Page Zero Addressing            1       address in page zero that contains the address of the operand
IG	Indirect Global Addressing               2       real address that contains the address of the operand
II	Indirect Indexed Addressing              2       address relative to dataIndex that contains the address of the operand









================================================================================ 18/11/2019
== Instructions / vue d'ensemble

Une des inspirations principales est CoreWars, parce qu'il y a ce côté "fight" déjà présent. Dans l'esprit, le jeu d'instruction du Redcode du MARS est très simple, même si les modifieurs du standard '94 ajoutent pas mal de possibilités. C'est d'emblée orienté 1vs1, pour de petits combats courts. Mais l'ambition qu'on a ici, c'est de faire un MUD, ou disons l'équivalent d'un MUD, ce qui implique une complexité potentielle des programmes bien plus grande.

Tout est parti d'un constat que j'ai fait en travaillant sur un autre projet, de MUD justement, basé sur un univers cybermédiéval somme toute banal. J'ai été rebuté dès que j'ai commencé à travaillé sur l'IA des PNJ, parce qu'en comparaison d'un JdR tabletop à l'ancienne, les PNJ d'un MUD me semblaient toujours trop mécaniques, comme des pantins automatisés. Donc j'avais transformé ce projet de MUD en projet de JdR classique, et en repensant à ça j'ai eu une micro-illumination sous la douche, en me disant que les PNJ d'un MUD se comportant comme des programmes, le scénario idéalement adapté à cet outil serait un scénario à la Tron, où les personnages sont justement des programmes. Il y a eu une petite étincelle. Je suis vite allé me replonger dans un manuel CoreWars pour me remettre dans l'ambiance, et zou c'était parti.

CoreWars est la première source d'inspiration pour l'instruction set. La seconde, c'est le Z80 et le 6502. Le Z80 c'est ce qu'il y avait dans l'AMSTRAD de mon enfance, donc j'aurai toujours un petit crush pour lui. La troisième source, c'est NASM, par le biais d'un livre très bien fait et libre d'accès : "Langage Assembleur PC", de Paul A.Carter, traduit par Sébastien Le Ray (2005). Je suis loin, mais alors très loin d'être un expert en langage assembleur, langage machine, fonctionnement des CPU, ...etc. Donc c'est important d'avoir de la doc.

Je commence juste à concevoir les instructions. L'idée c'est de partir des quelques instructions de base de CoreWars, et d'ajouter tout ce qu'on peut trouver dans les vrais CPU 8 bits de l'époque. On doit concevoir à la fois le langage d'assembleur que l'utilisateur aura face à lui, et le bytecode correspondant, puisque les programmes pourront le manipuler.

J'ai choisi un format particulier pour le bytecode : tout sur 4 octets. Cela créé une certaine contrainte au niveau de la création du jeu d'instruction, ce qui est plutôt sympa, et cela permettra d'avoir un alignement simplifiant grandement la programmation "en jeu", et l'univers en général. Comme je disais dans le post précédent, une instruction se présente comme ceci :

+--------+--------+-----------------+
| Opcode | Field1 |     Field2      |
|  0x00  |  0x00  |     0x0000      |
+--------+--------+-----------------+

C'est le format général, il peut y avoir des variantes mais le plus souvent une instruction peut prendre deux arguments, le premier sur 1 octet, le deuxième sur 1 mot. Dans tous les cas, une instruction ne prendra jamais moins de 4 octets, ni plus. Toute la subtilité sera de "remplir" judicieusement toutes les combinaisons possibles, avec des choses utiles.

Justement, qu'est-ce qui sera utile ? Question délicate, mais tout le système est conçu pour justifier un certain nombre de choses au niveau du scénario. Par exemple, dans l'imaginaire collectif, et dans un film comme Tron, on voit des programmes se "déplacer" dans des "endroits". Rien que ça, ça pose question. Il n'y a rien de tel dans un vrai ordinateur. A la limite dans un réseau, des informations transitent, mais ce ne sont pas des programmes actifs qui se déplacent d'eux-mêmes, ce sont des informations inertes qu'un programme actif, local, immobile, transmet à un autre programme, distant, immobile lui aussi. Comment justifier cette histoire de programmes qui se déplacent ? En découpant la mémoire du système en petits segments de 64Ko autonomes, chacun avec son petit CPU. On imagine donc de petites micro-chips en grand nombre, connectées en grille. Chaque micro-chip correspond à un "lieu", c'est à dire une room en parlance MUD, et les programmes peuvent effectivement se déplacer de lieu en lieu, en sautant d'une micro-chip à l'autre. Ca justifie l'aspect "géographique", et aussi le terme de "grille", qui pète, quand même, hein.

Autre point de scénario à justifier, ce serait l'idée d'objets physiques, et la possibilité pour les programmes de les déplacer. Les scénarios peuvent contenir des missions comme le transport sécurisé d'information, ou à l'inverse le vol d'information, la sécurisation d'une zone, ou l'intrusion dans une zone, ...etc. Bon, les objets, ce sont des informations. Dans les MUD, il y a aussi parfois des objets contenant d'autres objets, comme des coffres par exemple. L'équivalent, ce serait une zone de donnée compressée. Compressé, le coffre est fermé, décompressé le coffre est ouvert.

Dans les MUD il y a parfois des portes fermées à clef. Cela correspondrait à la nécessité de fournir un mot de passe à la micro-chip voisine lors d'une demande de transfert. Bien sûr il faudrait qu'il y ait moyen de casser le code, pour reproduire l'idée d'entrée par effraction.

Enfin, on a besoin d'un groupe de programmes organisés, et faisant régner la loi, un régime totalitaire, dictatorial et esclavagiste, martyrisant les pauvres petits programmes qui ne demandent qu'à vivre tranquille. Comme l'Empire dans Star Wars. L'équivalent peut être produit grâce à un système de droits, accordés ou non aux programmes, et qui donne un avantage aux "soldats" du régime. Bah oui il faut que la lutte soit inégale, sinon il n'y a pas de bravoure, pas de héros. Là on pourra se battre pour "libérer le système", quoi que cela veuille dire. Mais là aussi, il faudra prévoir des moyens de contourner le système, sinon c'est pas drôle. Les droits pourraient comprendre par exemple l'accès à la page zéro, ou l'utilisation d'instructions particulièrement puissantes de copie, ou d'autre type.

Pour autant, il faut que le système soit utilisable pour faire des choses (au moins un peu) utiles. Les chips doivent pouvoir être connectées à des devices HTML/CSS/JS. En quelque sorte, certaines zones d'une page HTML jouent le rôle de hardware périphérique. On peut imaginer des div tuiles par exemple, façon Metro. 









================================================================================ 18/11/2019
== Environnements

On créé 2 processus, le premier avec 2 threads et le second avec un seul. Puis on créé un troisième thread pour le premier processus. On obtient en page zéro les valeurs ci-dessous, en hexadécimal. Les "00" sont remplacés par ".." pour une meilleure lisibilité.

30 4A .. .. .. .. .. .. .. .. .. .. .. .. .. .. F8 .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 57 3D 01 80 01 40 01 60 01 01 .. .. .. 30 57 02
80 02 40 02 60 02 01 .. .. .. 4A 4A 03 80 03 40 03 60 03 01 .. .. .. 3D 30 04 80 04 40 04 60 04
01 .. .. .. 71 .. .. .. .. .. .. .. .. .. .. .. .. 7E .. .. .. .. .. .. .. .. .. .. .. .. 8B ..
.. .. .. .. .. .. .. .. .. .. .. 98 .. .. .. .. .. .. .. .. .. .. .. .. A5 .. .. .. .. .. .. ..
.. .. .. .. .. B2 .. .. .. .. .. .. .. .. .. .. .. .. BF .. .. .. .. .. .. .. .. .. .. .. .. CC
.. .. .. .. .. .. .. .. .. .. .. .. D9 .. .. .. .. .. .. .. .. .. .. .. .. E6 .. .. .. .. .. ..
.. .. .. .. .. .. F3 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..

Les 16 premiers octets forment le Scheduler.

30 4A .. .. .. .. .. .. .. .. .. .. .. .. .. ..

Chaque processus a un octet attribué dans cet plage. Cet octet pointe sur l'environnement en cours d'exécution, ou sur le prochain environnement à exécuter. Ici on voit qu'il y a deux processus. Pour le processus 0, le prochain environnement à exécuter est situé à l'adresse 30, et pour le processus 1, le prochain environnement à exécuter est à l'adresse 4A.

Les environnements sont composés de 13 octets. Voici celui situé à l'adresse 30.

57 3D 01 80 01 40 01 60 01 01 .. .. ..

Voici la composition de cet environnement

Position  Valeur  Nom                    Description
--------  ------  ---                    -----------
0         57      nextEnv                Adresse du prochain environnement à exécuter
1         3D      previousEnv            Adresse de l'environnement précédent
2         01      programCounter (hi)    Adresse de la prochaine instruction à exécuter (page)
3         80      programCounter (lo)    Adresse de la prochaine instruction à exécuter (offset)
4         01      stackPointer (hi)      Adresse de la pile (page)
5         40      stackPointer (lo)      Adresse de la pile (offset)
6         01      interruptHandler (hi)  Adresse du gestionnaire d'interruption (page)
7         60      interruptHandler (lo)  Adresse du gestionnaire d'interruption (offset)
8         01      dataIndex              Numéro de la première page du thread
9         01      dataLength             Nombre de pages réservées au thread
A         00      accumulator (hi)       Valeur actuelle de l'accumulateur (octet haut)
B         00      accumulator (lo)       Valeur actuelle de l'accumulateur (octet bas)
C         00      flagRegister           Valeur actuelle des flags du thread

Sur un processeur classique style 6502 ou Z80, il n'y a pas de multitâche bien sûr. Mais dans notre cas, on souhaite pouvoir héberger plusieurs programmes actifs en même temps, comme dans CoreWars par exemple. Donc au lieu d'utiliser les registres du processeur, ce qui obligerait à faire des gesticulations sans fin, on utilise des environnements placés en page zéro, qui font office de "registres personnels" d'un thread.

Cela reste très sommaire, et le choix d'utiliser 13 octets n'est pas anodin. En fait on a pour la page zéro 16 octets pour le Scheduler, mais on a aussi une memory map (MMAP) qui occupe 32 octets, et dans laquelle chaque bit représente l'occupation d'une page. 32 octets x 8 bits = 256 bits, on a bien nos 256 pages correspondant aux 64Ko d'un système. La MMAP ressemble à ceci, en binaire (les '0' sont remplacés par des '.' pour une meilleure lisibilité)

11111... ........ ........ ........ ........ ........ ........ ........
........ ........ ........ ........ ........ ........ ........ ........
........ ........ ........ ........ ........ ........ ........ ........
........ ........ ........ ........ ........ ........ ........ ........

La page zéro est toujours occupée, et on a ensuite nos 4 threads, pour un total de 5 pages occupées. Bref tout ça pour dire qu'on a 16 octet SCHED + 32 octets octets MMAP = 48 octets. Il reste donc 256 - 48 = 208 octets pour le reste de la page zéro. Et qu'est-ce qui peut diviser 208 ? bah 13 justement, 13 x 16 = 208... ça tombe bien non ? Voilà comme je disais, c'est pas anodin. On peut avoir maximum 16 environnements en page zéro.

Revenons à nos moutons, et passons en revue les différents composants d'un environnement.

En 0, l'octet nextEnv est l'adresse du prochain environnement à exécuter. Quand cet environnement aura été exécuté, c'est cette valeur qui sera placée dans le SCHED.

En 1, l'octet previousEnv est l'adresse du précédent environnement. On en a besoin pour former une linked list circulaire. En effet quand un thread prendra fin, on connectera le nextEnv du thread précédent au prochain thread, et le previousEnv du thread suivant au thread précédent.

En 2 et 3, on a le mot programCounter, qui contient l'adresse de la prochaine instruction à exécuter. C'est l'adresse réelle dans les 64Ko de mémoire.

En 4 et 5, c'est le mot stackPointer, qui contient l'adresse du haut de la pile. C'est l'adresse réelle dans les 64Ko de mémoire. Au passage, signalons qu'il n'y aura aucune vérification de faite ; si on PUSH ou POP comme un malade, il se passera des funny things.

En 6 et 7, on a le mot interruptHandler, qui contient l'adresse du gestionnaire d'interruption. C'est l'adresse réelle dans les 64Ko de mémoire. A ce stade, ce gestionnaire n'est pas encore conçu, mais l'idée générale est d'avoir un numéro associé à chaque type d'interruption, et ce numéro sera un indice pour le tableau d'adresses contenu à l'adresse de l'interruptHandler, qui renverra vers la section de code appropriée.

En 8, on a l'octet dataIndex, qui est le numéro de la première page réservée au thread. Quand on créé un thread, on demande l'allocation d'un certain nombre de pages. S'il y a en mémoire suffisamment de pages libres adjacentes, elles lui sont attribuées, et dataIndex reçoit le numéro de la première page attribuée. Précisons que quand un thread est éliminé, aucune défragmentation n'est pratiquée. On est bas-niveau quand même, faut pas déconner.

En 9, c'est l'octet dataLength, qui est le nombre de pages allouées au thread.

En A et B, on a le mot accumulator. Cela peut sembler maigrichon, voire radin, de ne pas avoir de registres general purpose comme sur les processeurs classiques. Mais en fait beaucoup d'opcodes feront référence directement à la première page allouée au thread, avec un adressage sur un seul octet, donc. On parlera des opcodes plus tard, mais on peut déjà dire qu'ils sont tous sur 4 octets (par soucis de simplicité d'alignement, dans la mesure où les programmes sont censés se fighter de temps en temps), 1 octet pour l'opcode, puis field1 sur 1 octet, puis field2 sur 2 octets.

Enfin en C, on trouve l'octet flagRegister. Classique.

Mettons côte à côte les 4 environnements de notre exemple. Ils apparaîssent dans l'ordre où ils ont été créés.

Adresse  Environnement
-------  -------------
30       57 3D 01 80 01 40 01 60 01 01 .. .. ..
3D       30 57 02 80 02 40 02 60 02 01 .. .. ..
4A       4A 4A 03 80 03 40 03 60 03 01 .. .. ..
57       3D 30 04 80 04 40 04 60 04 01 .. .. ..

Le premier, le deuxième et le dernier appartiennent au processus 0. Le troisième appartient au processus 1.

D'abord en regardant les deux premiers octets de chacun, on voit bien la linked list circulaire. 30 pointe sur 57, qui pointe sur 3D, qui pointe sur 30. 4A pointe sur lui-même puisqu'il est l'unique thread de son processus.

Le troisième, le cinquième et le septième octet montrent le numéro de page. Ce sont respectivement les octets forts du programCounter, du stackPointer, et de l'interruptHandler. Comme on a créé ces threads en laissant les valeurs par défaut, tout se retrouve en première page de chaque thread. Pour le premier thread, on voit le programCounter à 0x0180, le stackPointer à 0x0140, et l'interruptHandler à 0x0160.

Ensuite en neuvième position, on a le numéro de page correspondant au dataIndex, suivi en dixième position du dataLength qui est à 1 pour tout le monde, ce qui est la valeur par défaut : 1 page.

Enfin, on a l'accu à 0x0000, et le flagRegister à 0x00, qui sont là encore les valeurs par défaut.

Voilà, je crois qu'on a fait le tour de la notion d'environnement, à peu près.

